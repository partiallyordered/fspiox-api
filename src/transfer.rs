// Definitions in this file should map directly to definitions in api.yaml
// TODO: can this whole module be replaced by something that comes out of swagger generator?
// TODO: implement validation
//       https://blog.logrocket.com/json-input-validation-in-rust-web-services/
//       or try swagger generator?

use serde::{Serialize, Deserialize};
use crate::*;
use strum_macros::EnumString;
use derive_more::{FromStr, Display};
use chrono::Utc;

#[cfg(feature = "typescript_types")]
use ts_rs::TS;

#[derive(Debug)]
pub struct MlApiAdapterRequest(crate::FspiopRequest);

// ^[A-Za-z0-9-_]{43}$
// TODO: validation
#[derive(Deserialize, Serialize, Debug, Copy, Clone, Hash, PartialEq, Eq, Display)]
pub struct IlpCondition(arrayvec::ArrayString<43>);

impl IlpCondition {
    pub fn from(item: &str) -> Result<Self, arrayvec::CapacityError<&str>> {
        Ok(IlpCondition(arrayvec::ArrayString::from(item)?))
    }
}

#[cfg(feature = "typescript_types")]
impl TS for IlpCondition {
    fn name() -> String {
        "IlpCondition".to_string()
    }

    fn dependencies() -> Vec<(std::any::TypeId, String)> {
        Vec::new()
    }

    fn transparent() -> bool { false }

    fn decl() -> String {
        "type IlpCondition = string".to_string()
    }
}

// ^[A-Za-z0-9-_]+[=]{0,2}$
// minLength: 1, maxLength: 32768
// TODO: validation
// TODO: we've limited the size of the ILP packet here because:
// 1. we're not the actual ML API
// 2. 32768 bytes?! Yeah, I get it. But I'd probably limit that on my own API for performance.
#[derive(Deserialize, Serialize, Debug, Copy, Clone, Hash, PartialEq, Eq, Display, FromStr)]
pub struct IlpPacket(arrayvec::ArrayString<256>);

impl IlpPacket {
    pub fn from(item: &str) -> Result<Self, arrayvec::CapacityError<&str>> {
        Ok(IlpPacket(arrayvec::ArrayString::from(item)?))
    }
}


#[cfg(feature = "typescript_types")]
impl TS for IlpPacket {
    fn name() -> String {
        "IlpPacket".to_string()
    }

    fn dependencies() -> Vec<(std::any::TypeId, String)> {
        Vec::new()
    }

    fn transparent() -> bool { false }

    fn decl() -> String {
        "type IlpPacket = string".to_string()
    }
}

#[derive(Deserialize, Serialize, Debug, Copy, Clone, Hash, PartialEq, Eq, FromStr, Display)]
pub struct TransferId(pub CorrelationId);

#[cfg(feature = "typescript_types")]
impl TS for TransferId {
    fn name() -> String {
        "TransferId".to_string()
    }

    fn dependencies() -> Vec<(std::any::TypeId, String)> {
        Vec::new()
    }

    fn transparent() -> bool { false }

    fn decl() -> String {
        "type TransferId = string".to_string()
    }
}

#[cfg_attr(feature = "typescript_types", derive(TS))]
#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub struct TransferPrepareRequestBody {
    pub transfer_id: TransferId,
    pub payee_fsp: FspId,
    pub payer_fsp: FspId,
    pub amount: Money,
    pub ilp_packet: IlpPacket,
    pub condition: IlpCondition,
    pub expiration: DateTime,
    // TODO: handle extensionList
}

impl TransferPrepareRequestBody {
    pub fn generate(
        payer_fsp: FspId,
        payee_fsp: FspId,
        amount: Amount,
        currency: Currency,
        transfer_id: Option<TransferId>,
    ) -> TransferPrepareRequestBody {
        TransferPrepareRequestBody {
            transfer_id: transfer_id.unwrap_or(TransferId(CorrelationId::new())),
            payer_fsp,
            payee_fsp,
            amount: common::Money {
                amount,
                currency,
            },
            // TODO: build ilp_packet correctly
            ilp_packet: transfer::IlpPacket::from("ilp_packet").unwrap(),
            // /^[A-Za-z0-9-_]{43}$/"
            // TODO: expose the condition as a parameter. Note: the relationship between
            // condition and fulfilment is this:
            //   preimage: 32 byte secret, generated by FSP; a good implementation may be 32 random bytes
            //   fulfilment: base64url(preimage)
            //   condition: base64url(sha256digest(preimage))
            // Note that the condition is the result of a one-way function of the preimage, and
            // both are simply base64url encoded in transit. The key piece of information here
            // is that the condition is used as a challenge, and the fulfilment is the correct
            // response to that challenge, that verifies the issuer of the condition owns the
            // preimage.
            // See also the Mojaloop fulfilment validation code here:
            //   https://github.com/mojaloop/central-ledger/blob/01435fda1d61093b2e20ff2385e8d65393dac640/src/handlers/transfers/validator.js#L142
            condition: transfer::IlpCondition::from("mDl1row96r7GHMZywWheDMzDJkvBB-iC2i0mR_vU870").unwrap(),
            expiration: common::DateTime(Utc::now().checked_add_signed(chrono::Duration::hours(1)).unwrap()),
        }
    }
}

// pattern: ^[A-Za-z0-9-_]{43}$
// but..
// maxLength: 48
// according to the openapi spec
// TODO: validation
#[derive(Deserialize, Serialize, Debug, Copy, Clone, Hash, PartialEq, Eq, Display)]
pub struct IlpFulfilment(arrayvec::ArrayString<43>);

impl IlpFulfilment {
    pub fn from(item: &str) -> Result<Self, arrayvec::CapacityError<&str>> {
        Ok(IlpFulfilment(arrayvec::ArrayString::from(item)?))
    }
}

#[cfg(feature = "typescript_types")]
impl TS for IlpFulfilment {
    fn name() -> String {
        "IlpFulfilment".to_string()
    }

    fn dependencies() -> Vec<(std::any::TypeId, String)> {
        Vec::new()
    }

    fn transparent() -> bool { false }

    fn decl() -> String {
        "type IlpFulfilment = string".to_string()
    }
}

#[derive(Serialize, Deserialize, Debug, EnumString, Clone, Copy)]
pub enum TransferState {
    RECEIVED,
    RESERVED,
    COMMITTED,
    ABORTED,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub struct TransferFulfilRequestBody {
    // TODO:
    // The spec doesn't actually require all of these fields. This is because the requests
    // supported by PUT /transfers/$id are actually of three different types, depending on the
    // provided transfer_state. See:
    //   https://github.com/mojaloop/mojaloop-specification/blob/a66ea83f2a0c1e0073fe8bf93f301c01469d025d/fspiop-api/documents/v1.1-document-set/fspiop-v1.1-openapi2.yaml#L4358-L4359
    // This is a shortcoming of Swagger, and is probably best modeled as a sum type in Rust.
    pub fulfilment: IlpFulfilment,
    pub completed_timestamp: DateTime,
    pub transfer_state: TransferState,
    // TODO: handle extensionList
}

impl TransferFulfilRequestBody {
    pub fn generate() -> TransferFulfilRequestBody {
        TransferFulfilRequestBody {
            // TODO: expose the fulfilment as a parameter. Note: the relationship between
            // condition and fulfilment is this:
            //   preimage: 32 byte secret, generated by FSP; a good implementation may be 32 random bytes
            //   fulfilment: base64url(preimage)
            //   condition: base64url(sha256digest(preimage))
            // Note that the condition is the result of a one-way function of the preimage, and
            // both are simply base64url encoded in transit. The key piece of information here
            // is that the condition is used as a challenge, and the fulfilment is the correct
            // response to that challenge, that verifies the issuer of the condition owns the
            // preimage.
            // See also the Mojaloop fulfilment validation code here:
            //   https://github.com/mojaloop/central-ledger/blob/01435fda1d61093b2e20ff2385e8d65393dac640/src/handlers/transfers/validator.js#L142
            // /^[A-Za-z0-9-_]{43}$/"
            fulfilment: IlpFulfilment::from("D2ICC9fGiWtKYf9PBRsFE8Dliem2iLqOajj56FuIVxc").unwrap(),
            completed_timestamp: crate::DateTime(Utc::now()),
            transfer_state: TransferState::COMMITTED,
        }
    }
}

#[derive(Debug, Clone)]
pub struct TransferFulfilRequest(pub FspiopRequest);

impl TransferFulfilRequest {
    pub fn new(payer: FspId, payee: FspId, id: TransferId) -> TransferFulfilRequest {
        TransferFulfilRequest(
            FspiopRequest {
                source: payee.clone(),
                destination: payer.clone(),
                path: format!("/transfers/{}", id).parse::<http::Uri>().unwrap(),
                resource: FspiopResource::Transfers,
                method: FspiopMethod::PUT,
                request_api_version: ApiVersion::V1pt0,
                accept_api_versions: vec![ApiVersion::V1pt0],
                date: Some(Utc::now()),
                body: FspiopRequestBody::TransferFulfil(transfer::TransferFulfilRequestBody::generate()),
            }
        )
    }
}

#[derive(Debug, Clone)]
pub struct TransferPrepareRequest(pub FspiopRequest);

impl TransferPrepareRequest {
    pub fn new(
        payer_fsp: FspId,
        payee_fsp: FspId,
        amount: Amount,
        currency: Currency,
        id: Option<TransferId>,
    ) -> TransferPrepareRequest {
        let id = id.unwrap_or(TransferId(CorrelationId::new()));
        TransferPrepareRequest(
            FspiopRequest {
                source: payer_fsp.clone(),
                destination: payee_fsp.clone(),
                path: "/transfers".parse::<http::Uri>().unwrap(),
                resource: FspiopResource::Transfers,
                method: FspiopMethod::POST,
                request_api_version: ApiVersion::V1pt0,
                accept_api_versions: vec![ApiVersion::V1pt0],
                date: Some(Utc::now()),
                body: FspiopRequestBody::TransferPrepare(TransferPrepareRequestBody::generate(
                    payer_fsp,
                    payee_fsp,
                    amount,
                    currency,
                    Some(id),
                )),
            }
        )
    }
}
