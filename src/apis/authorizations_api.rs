/*
 * Open API for FSP Interoperability (FSPIOP)
 *
 * Based on API Definition.docx updated on 2020-05-19 Version 1.1. Note - The API supports a maximum size of 65536 bytes (64 Kilobytes) in the HTTP header.
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `authorizations_by_id_and_error`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthorizationsByIdAndErrorError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `authorizations_by_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthorizationsByIdGetError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `authorizations_by_id_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthorizationsByIdPutError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}


/// If the server is unable to find the transaction request, or another processing error occurs, the error callback PUT /authorizations/<ID>/error is used. The <ID> in the URI should contain the <ID> that was used in the GET /authorizations/<ID>.
pub async fn authorizations_by_id_and_error(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<AuthorizationsByIdAndErrorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/authorizations/{ID}/error", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthorizationsByIdAndErrorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request GET /authorizations/<ID> is used to request the Payer to enter the applicable credentials in the Payee FSP system. The <ID> in the URI should contain the transactionRequestID, received from the POST /transactionRequests service earlier in the process. This request requires a query string to be included in the URI, with the following key-value pairs - authenticationType=<Type>, where <Type> value is a valid authentication type from the enumeration AuthenticationType. retriesLeft==<NrOfRetries>, where <NrOfRetries> is the number of retries left before the financial transaction is rejected. <NrOfRetries> must be expressed in the form of the data type Integer. retriesLeft=1 means that this is the last retry before the financial transaction is rejected. amount=<Amount>, where <Amount> is the transaction amount that will be withdrawn from the Payer’s account. <Amount> must be expressed in the form of the data type Amount. currency=<Currency>, where <Currency> is the transaction currency for the amount that will be withdrawn from the Payer’s account. The <Currency> value must be expressed in the form of the enumeration CurrencyCode. An example URI containing all the required key-value pairs in the query string is the following - GET /authorization/3d492671-b7af-4f3f-88de-76169b1bdf88?authenticationType=OTP&retriesLeft=2&amount=102&currency=USD
pub async fn authorizations_by_id_get(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<AuthorizationsByIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/authorizations/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthorizationsByIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /authorizations/<ID> is used to inform the client of the result of a previously-requested authorization. The <ID> in the URI should contain the <ID> that was used in the GET /authorizations/<ID>.
pub async fn authorizations_by_id_put(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::AuthorizationsIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<AuthorizationsByIdPutError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/authorizations/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthorizationsByIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

