/*
 * Open API for FSP Interoperability (FSPIOP)
 *
 * Based on API Definition.docx updated on 2020-05-19 Version 1.1. Note - The API supports a maximum size of 65536 bytes (64 Kilobytes) in the HTTP header.
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `participants1`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Participants1Error {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_by_id_and_error`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsByIdAndErrorError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_by_id_and_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsByIdAndTypeError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_by_id_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsByIdPutError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_by_type_and_id2`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsByTypeAndId2Error {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_by_type_and_id3`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsByTypeAndId3Error {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_error_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsErrorByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_sub_id_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsSubIdByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_sub_id_by_type_and_id2`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsSubIdByTypeAndId2Error {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_sub_id_by_type_and_id3`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsSubIdByTypeAndId3Error {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_sub_id_by_type_and_id_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsSubIdByTypeAndIdPostError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `participants_sub_id_error_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParticipantsSubIdErrorByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}


/// The HTTP request POST /participants is used to create information in the server regarding the provided list of identities. This request should be used for bulk creation of FSP information for more than one Party. The optional currency parameter should indicate that each provided Party supports the currency
pub async fn participants1(configuration: &configuration::Configuration, accept: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ParticipantsPostRequest, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<Participants1Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<Participants1Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If there is an error during FSP information creation in the server, the error callback PUT /participants/{ID}/error is used. The <ID> in the URI should contain the requestId that was used for the creation of the participant information.
pub async fn participants_by_id_and_error(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsByIdAndErrorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{ID}/error", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsByIdAndErrorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request POST /participants/<Type>/<ID> (or POST /participants/<Type>/<ID>/<SubId>) is used to create information in the server regarding the provided identity, defined by <Type>, <ID>, and optionally <SubId> (for example, POST /participants/MSISDN/123456789 or POST /participants/BUSINESS/shoecompany/employee1). An ExtensionList element has been added to this request in version v1.1
pub async fn participants_by_id_and_type(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, body: crate::models::ParticipantsTypeIdSubIdPostRequest, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<ParticipantsByIdAndTypeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsByIdAndTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /participants/<ID> is used to inform the client of the result of the creation of the provided list of identities.
pub async fn participants_by_id_put(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ParticipantsIdPutResponse, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsByIdPutError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsByIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request GET /participants/<Type>/<ID> (or GET /participants/<Type>/<ID>/<SubId>) is used to find out in which FSP the requested Party, defined by <Type>, <ID> and optionally <SubId>, is located (for example, GET /participants/MSISDN/123456789, or GET /participants/BUSINESS/shoecompany/employee1). This HTTP request should support a query string for filtering of currency. To use filtering of currency, the HTTP request GET /participants/<Type>/<ID>?currency=XYZ should be used, where XYZ is the requested currency.
pub async fn participants_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request DELETE /participants/<Type>/<ID> (or DELETE /participants/<Type>/<ID>/<SubId>) is used to delete information in the server regarding the provided identity, defined by <Type> and <ID>) (for example, DELETE /participants/MSISDN/123456789), and optionally <SubId>. This HTTP request should support a query string to delete FSP information regarding a specific currency only. To delete a specific currency only, the HTTP request DELETE /participants/<Type>/<ID>?currency=XYZ should be used, where XYZ is the requested currency. Note -  The Account Lookup System should verify that it is the Party’s current FSP that is deleting the FSP information.
pub async fn participants_by_type_and_id2(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsByTypeAndId2Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsByTypeAndId2Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /participants/<Type>/<ID> (or PUT /participants/<Type>/<ID>/<SubId>) is used to inform the client of a successful result of the lookup, creation, or deletion of the FSP information related to the Party. If the FSP information is deleted, the fspId element should be empty; otherwise the element should include the FSP information for the Party.
pub async fn participants_by_type_and_id3(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ParticipantsTypeIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<ParticipantsByTypeAndId3Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsByTypeAndId3Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the server is unable to find, create or delete the associated FSP of the provided identity, or another processing error occurred, the error callback PUT /participants/<Type>/<ID>/error (or PUT /participants/<Type>/<ID>/<SubId>/error) is used.
pub async fn participants_error_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsErrorByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}/error", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsErrorByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request GET /participants/<Type>/<ID> (or GET /participants/<Type>/<ID>/<SubId>) is used to find out in which FSP the requested Party, defined by <Type>, <ID> and optionally <SubId>, is located (for example, GET /participants/MSISDN/123456789, or GET /participants/BUSINESS/shoecompany/employee1). This HTTP request should support a query string for filtering of currency. To use filtering of currency, the HTTP request GET /participants/<Type>/<ID>?currency=XYZ should be used, where XYZ is the requested currency.
pub async fn participants_sub_id_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsSubIdByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}/{SubId}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsSubIdByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request DELETE /participants/<Type>/<ID> (or DELETE /participants/<Type>/<ID>/<SubId>) is used to delete information in the server regarding the provided identity, defined by <Type> and <ID>) (for example, DELETE /participants/MSISDN/123456789), and optionally <SubId>. This HTTP request should support a query string to delete FSP information regarding a specific currency only. To delete a specific currency only, the HTTP request DELETE /participants/<Type>/<ID>?currency=XYZ should be used, where XYZ is the requested currency. Note -  The Account Lookup System should verify that it is the Party’s current FSP that is deleting the FSP information.
pub async fn participants_sub_id_by_type_and_id2(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsSubIdByTypeAndId2Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}/{SubId}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsSubIdByTypeAndId2Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /participants/<Type>/<ID> (or PUT /participants/<Type>/<ID>/<SubId>) is used to inform the client of a successful result of the lookup, creation, or deletion of the FSP information related to the Party. If the FSP information is deleted, the fspId element should be empty; otherwise the element should include the FSP information for the Party.
pub async fn participants_sub_id_by_type_and_id3(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ParticipantsTypeIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<ParticipantsSubIdByTypeAndId3Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}/{SubId}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsSubIdByTypeAndId3Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request POST /participants/<Type>/<ID> (or POST /participants/<Type>/<ID>/<SubId>) is used to create information in the server regarding the provided identity, defined by <Type>, <ID>, and optionally <SubId> (for example, POST /participants/MSISDN/123456789 or POST /participants/BUSINESS/shoecompany/employee1). An ExtensionList element has been added to this reqeust in version v1.1
pub async fn participants_sub_id_by_type_and_id_post(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, body: crate::models::ParticipantsTypeIdSubIdPostRequest, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<ParticipantsSubIdByTypeAndIdPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}/{SubId}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsSubIdByTypeAndIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the server is unable to find, create or delete the associated FSP of the provided identity, or another processing error occurred, the error callback PUT /participants/<Type>/<ID>/error (or PUT /participants/<Type>/<ID>/<SubId>/error) is used.
pub async fn participants_sub_id_error_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<ParticipantsSubIdErrorByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/participants/{Type}/{ID}/{SubId}/error", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<ParticipantsSubIdErrorByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

