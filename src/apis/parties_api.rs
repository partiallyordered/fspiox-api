/*
 * Open API for FSP Interoperability (FSPIOP)
 *
 * Based on API Definition.docx updated on 2020-05-19 Version 1.1. Note - The API supports a maximum size of 65536 bytes (64 Kilobytes) in the HTTP header.
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `parties_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartiesByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `parties_by_type_and_id2`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartiesByTypeAndId2Error {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `parties_error_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartiesErrorByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `parties_sub_id_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartiesSubIdByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `parties_sub_id_by_type_and_id_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartiesSubIdByTypeAndIdPutError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `parties_sub_id_error_by_type_and_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartiesSubIdErrorByTypeAndIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}


/// The HTTP request GET /parties/<Type>/<ID> (or GET /parties/<Type>/<ID>/<SubId>) is used to lookup information regarding the requested Party, defined by <Type>, <ID> and optionally <SubId> (for example, GET /parties/MSISDN/123456789, or GET /parties/BUSINESS/shoecompany/employee1).
pub async fn parties_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<PartiesByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/parties/{Type}/{ID}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PartiesByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /parties/<Type>/<ID> (or PUT /parties/<Type>/<ID>/<SubId>) is used to inform the client of a successful result of the Party information lookup.
pub async fn parties_by_type_and_id2(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::PartiesTypeIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<PartiesByTypeAndId2Error>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/parties/{Type}/{ID}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PartiesByTypeAndId2Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the server is unable to find Party information of the provided identity, or another processing error occurred, the error callback PUT /parties/<Type>/<ID>/error (or PUT /parties/<Type>/<ID>/<SubId>/error) is used.
pub async fn parties_error_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<PartiesErrorByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/parties/{Type}/{ID}/error", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PartiesErrorByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request GET /parties/<Type>/<ID> (or GET /parties/<Type>/<ID>/<SubId>) is used to lookup information regarding the requested Party, defined by <Type>, <ID> and optionally <SubId> (for example, GET /parties/MSISDN/123456789, or GET /parties/BUSINESS/shoecompany/employee1).
pub async fn parties_sub_id_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<PartiesSubIdByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/parties/{Type}/{ID}/{SubId}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PartiesSubIdByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /parties/<Type>/<ID> (or PUT /parties/<Type>/<ID>/<SubId>) is used to inform the client of a successful result of the Party information lookup.
pub async fn parties_sub_id_by_type_and_id_put(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::PartiesTypeIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<PartiesSubIdByTypeAndIdPutError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/parties/{Type}/{ID}/{SubId}", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PartiesSubIdByTypeAndIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the server is unable to find Party information of the provided identity, or another processing error occurred, the error callback PUT /parties/<Type>/<ID>/error (or PUT /parties/<Type>/<ID>/<SubId>/error) is used.
pub async fn parties_sub_id_error_by_type_and_id(configuration: &configuration::Configuration, _type: &str, ID: &str, sub_id: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<PartiesSubIdErrorByTypeAndIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/parties/{Type}/{ID}/{SubId}/error", configuration.base_path, Type=crate::apis::urlencode(_type), ID=crate::apis::urlencode(ID), SubId=crate::apis::urlencode(sub_id));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<PartiesSubIdErrorByTypeAndIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

