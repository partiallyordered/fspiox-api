/*
 * Open API for FSP Interoperability (FSPIOP)
 *
 * Based on API Definition.docx updated on 2020-05-19 Version 1.1. Note - The API supports a maximum size of 65536 bytes (64 Kilobytes) in the HTTP header.
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `transfers`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransfersError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transfers_by_id_and_error`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransfersByIdAndErrorError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transfers_by_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransfersByIdGetError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transfers_by_id_patch`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransfersByIdPatchError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transfers_by_id_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransfersByIdPutError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}


/// The HTTP request POST /transfers is used to request the creation of a transfer for the next ledger, and a financial transaction for the Payee FSP.
pub async fn transfers(configuration: &configuration::Configuration, accept: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::TransfersPostRequest, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<TransfersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transfers", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransfersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the server is unable to find or create a transfer, or another processing error occurs, the error callback PUT /transfers/<ID>/error is used. The <ID> in the URI should contain the transferId that was used for the creation of the transfer, or the <ID> that was used in the GET /transfers/<ID>.
pub async fn transfers_by_id_and_error(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<TransfersByIdAndErrorError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transfers/{ID}/error", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransfersByIdAndErrorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request GET /transfers/<ID> is used to get information regarding an earlier created or requested transfer. The <ID> in the URI should contain the transferId that was used for the creation of the transfer.
pub async fn transfers_by_id_get(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<TransfersByIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transfers/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransfersByIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request PATCH /transfers/<ID> is used by a Switch to update the state of an earlier reserved transfer, if the Payee FSP has requested a commit notification when the Switch has completed processing of the transfer. The <ID> in the URI should contain the transferId that was used for the creation of the transfer. Please note that this request does not generate a callback.
pub async fn transfers_by_id_patch(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::TransfersIdPatchResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<TransfersByIdPatchError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transfers/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransfersByIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /transfers/<ID> is used to inform the client of a requested or created transfer. The <ID> in the URI should contain the transferId that was used for the creation of the transfer, or the <ID> that was used in the GET /transfers/<ID>.
pub async fn transfers_by_id_put(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::TransfersIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<TransfersByIdPutError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transfers/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransfersByIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

