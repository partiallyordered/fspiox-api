/*
 * Open API for FSP Interoperability (FSPIOP)
 *
 * Based on API Definition.docx updated on 2020-05-19 Version 1.1. Note - The API supports a maximum size of 65536 bytes (64 Kilobytes) in the HTTP header.
 *
 * The version of the OpenAPI document: 1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `transaction_requests`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionRequestsError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transaction_requests_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionRequestsByIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transaction_requests_by_id_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionRequestsByIdPutError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `transaction_requests_error_by_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionRequestsErrorByIdError {
    Status400(crate::models::ErrorInformationResponse),
    Status401(crate::models::ErrorInformationResponse),
    Status403(crate::models::ErrorInformationResponse),
    Status404(crate::models::ErrorInformationResponse),
    Status405(crate::models::ErrorInformationResponse),
    Status406(crate::models::ErrorInformationResponse),
    Status501(crate::models::ErrorInformationResponse),
    Status503(crate::models::ErrorInformationResponse),
    UnknownValue(serde_json::Value),
}


/// The HTTP request POST /transactionRequests is used to request the creation of a transaction request for the provided financial transaction in the server.
pub async fn transaction_requests(configuration: &configuration::Configuration, accept: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::TransactionRequestsPostRequest, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<TransactionRequestsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transactionRequests", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransactionRequestsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The HTTP request GET /transactionRequests/<ID> is used to get information regarding an earlier created or requested transaction request. The <ID> in the URI should contain the transactionRequestId that was used for the creation of the transaction request.
pub async fn transaction_requests_by_id(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, accept: &str, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<TransactionRequestsByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transactionRequests/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Accept", accept.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransactionRequestsByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The callback PUT /transactionRequests/<ID> is used to inform the client of a requested or created transaction request. The <ID> in the URI should contain the transactionRequestId that was used for the creation of the transaction request, or the <ID> that was used in the GET /transactionRequests/<ID>.
pub async fn transaction_requests_by_id_put(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::TransactionRequestsIdPutResponse, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>, content_length: Option<i32>) -> Result<(), Error<TransactionRequestsByIdPutError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transactionRequests/{ID}", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransactionRequestsByIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// If the server is unable to find or create a transaction request, or another processing error occurs, the error callback PUT /transactionRequests/<ID>/error is used. The <ID> in the URI should contain the transactionRequestId that was used for the creation of the transaction request, or the <ID> that was used in the GET /transactionRequests/<ID>.
pub async fn transaction_requests_error_by_id(configuration: &configuration::Configuration, ID: &str, content_type: &str, date: &str, fspiop_source: &str, body: crate::models::ErrorInformationObject, content_length: Option<i32>, x_forwarded_for: Option<&str>, fspiop_destination: Option<&str>, fspiop_encryption: Option<&str>, fspiop_signature: Option<&str>, FSPIOP_URI: Option<&str>, fspiop_http_method: Option<&str>) -> Result<(), Error<TransactionRequestsErrorByIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/transactionRequests/{ID}/error", configuration.base_path, ID=crate::apis::urlencode(ID));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = content_length {
        local_var_req_builder = local_var_req_builder.header("Content-Length", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());
    local_var_req_builder = local_var_req_builder.header("Date", date.to_string());
    if let Some(local_var_param_value) = x_forwarded_for {
        local_var_req_builder = local_var_req_builder.header("X-Forwarded-For", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header("FSPIOP-Source", fspiop_source.to_string());
    if let Some(local_var_param_value) = fspiop_destination {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Destination", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_encryption {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Encryption", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_signature {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-Signature", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = FSPIOP_URI {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-URI", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fspiop_http_method {
        local_var_req_builder = local_var_req_builder.header("FSPIOP-HTTP-Method", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<TransactionRequestsErrorByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

