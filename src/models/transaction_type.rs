/* 
 * Open API for FSP Interoperability (FSPIOP)
 *
 * Based on API Definition.docx updated on 2020-05-19 Version 1.1. Note - The API supports a maximum size of 65536 bytes (64 Kilobytes) in the HTTP header.
 *
 * OpenAPI spec version: 1.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// TransactionType : Data model for the complex type TransactionType.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionType {
  /// Deposit, withdrawal, refund, …
  #[serde(rename = "scenario")]
  scenario: ::models::TransactionScenario,
  /// Possible sub-scenario, defined locally within the scheme.
  #[serde(rename = "subScenario")]
  sub_scenario: Option<::models::TransactionSubScenario>,
  /// Who is initiating the transaction - Payer or Payee
  #[serde(rename = "initiator")]
  initiator: ::models::TransactionInitiator,
  /// Consumer, agent, business, …
  #[serde(rename = "initiatorType")]
  initiator_type: ::models::TransactionInitiatorType,
  /// Extra information specific to a refund scenario. Should only be populated if scenario is REFUND
  #[serde(rename = "refundInfo")]
  refund_info: Option<::models::Refund>,
  /// Balance of Payments code.
  #[serde(rename = "balanceOfPayments")]
  balance_of_payments: Option<::models::BalanceOfPayments>
}

impl TransactionType {
  /// Data model for the complex type TransactionType.
  pub fn new(scenario: ::models::TransactionScenario, initiator: ::models::TransactionInitiator, initiator_type: ::models::TransactionInitiatorType) -> TransactionType {
    TransactionType {
      scenario: scenario,
      sub_scenario: None,
      initiator: initiator,
      initiator_type: initiator_type,
      refund_info: None,
      balance_of_payments: None
    }
  }

  pub fn set_scenario(&mut self, scenario: ::models::TransactionScenario) {
    self.scenario = scenario;
  }

  pub fn with_scenario(mut self, scenario: ::models::TransactionScenario) -> TransactionType {
    self.scenario = scenario;
    self
  }

  pub fn scenario(&self) -> &::models::TransactionScenario {
    &self.scenario
  }


  pub fn set_sub_scenario(&mut self, sub_scenario: ::models::TransactionSubScenario) {
    self.sub_scenario = Some(sub_scenario);
  }

  pub fn with_sub_scenario(mut self, sub_scenario: ::models::TransactionSubScenario) -> TransactionType {
    self.sub_scenario = Some(sub_scenario);
    self
  }

  pub fn sub_scenario(&self) -> Option<&::models::TransactionSubScenario> {
    self.sub_scenario.as_ref()
  }

  pub fn reset_sub_scenario(&mut self) {
    self.sub_scenario = None;
  }

  pub fn set_initiator(&mut self, initiator: ::models::TransactionInitiator) {
    self.initiator = initiator;
  }

  pub fn with_initiator(mut self, initiator: ::models::TransactionInitiator) -> TransactionType {
    self.initiator = initiator;
    self
  }

  pub fn initiator(&self) -> &::models::TransactionInitiator {
    &self.initiator
  }


  pub fn set_initiator_type(&mut self, initiator_type: ::models::TransactionInitiatorType) {
    self.initiator_type = initiator_type;
  }

  pub fn with_initiator_type(mut self, initiator_type: ::models::TransactionInitiatorType) -> TransactionType {
    self.initiator_type = initiator_type;
    self
  }

  pub fn initiator_type(&self) -> &::models::TransactionInitiatorType {
    &self.initiator_type
  }


  pub fn set_refund_info(&mut self, refund_info: ::models::Refund) {
    self.refund_info = Some(refund_info);
  }

  pub fn with_refund_info(mut self, refund_info: ::models::Refund) -> TransactionType {
    self.refund_info = Some(refund_info);
    self
  }

  pub fn refund_info(&self) -> Option<&::models::Refund> {
    self.refund_info.as_ref()
  }

  pub fn reset_refund_info(&mut self) {
    self.refund_info = None;
  }

  pub fn set_balance_of_payments(&mut self, balance_of_payments: ::models::BalanceOfPayments) {
    self.balance_of_payments = Some(balance_of_payments);
  }

  pub fn with_balance_of_payments(mut self, balance_of_payments: ::models::BalanceOfPayments) -> TransactionType {
    self.balance_of_payments = Some(balance_of_payments);
    self
  }

  pub fn balance_of_payments(&self) -> Option<&::models::BalanceOfPayments> {
    self.balance_of_payments.as_ref()
  }

  pub fn reset_balance_of_payments(&mut self) {
    self.balance_of_payments = None;
  }

}



